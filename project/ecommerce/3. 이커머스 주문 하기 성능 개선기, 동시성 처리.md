### 동시성 처리

nGrinder로 성능 테스트를 한 결과 주문/결제 건수와 재고 건수가 차이가 있다는걸 확인 할 수 있다.
목표 VUser보다 적은 수를 했음에도 이런 결과가 나왔다면, 목표 VUser가 100명일 때는 훨씬 더 많은 차이가 날 것이다.

<그림>

#### 요구사항 분석

주문하기 서비스에서 멱등성 있게 작동해야 한다. 또한 유지 보수성을 생각하면 scale out에 잘 맞아야 합니다.

고려해야할 사항
- 멱등성 : 주문하기 멱등성 있게 작동해야함
- Scale out : 유지보수성

#### 문제 해결
우선 현재 내게 주어진 환경에서 해결할 수 있는지 보자.
1. Java
   1. Synchronized Block
   2. Reentrant Lock
   3. CAS
2. DB
   1. Pessimistic Lock
   2. Optimistic Lock
3. Redis
   1. Distributed Lock

각 방법에는 장단점이 있지만 현재 요구사항은 Scale Out을 전제로 하였으니,
여러 WAS를 병렬적 수행할 수 있게 하는 시스템이므로 Java에서 제공하는 Locking 방법은 사용하지 못합니다.

우선 DB lock 중 하나인 Pessimistic Lock 을 사용하여 동시성 문제를 해결해보자

```java
@Transactional
public String order(Long productId, int quantity, Long memberId, LocalDateTime now) {
    Product product = productRepository.getLockBy(productId);
    product.checkQuantity(quantity);

    // 결제하기
    BigDecimal totalPrice = product.getPrice().multiply(BigDecimal.valueOf(quantity));
    paymentRepository.payment(totalPrice);

    // 주문서 생성
    Order order = Order.builder()
            .memberId(memberId)
            .ordersCode(now.format(DateTimeFormatter.ofPattern("yyyyMMddHHmmssSSS")))
            .build();
    Order createOrder = orderRepository.save(order);

    OrderDetail orderDetail = OrderDetail.builder()
            .ordersId(createOrder.getId())
            .productId(productId)
            .quantity(quantity)
            .price(totalPrice)
            .status(OrderDetail.OrderStatus.COMPLETE)
            .build();
    orderDetailRepository.save(orderDetail);

    product.deducted(quantity);
    productRepository.save(product);

    return order.getOrdersCode();
}

public interface ProductJpaRepository extends JpaRepository<ProductEntity, Long> {
    
   @Lock(LockModeType.PESSIMISTIC_WRITE)
   @Query("select p from ProductEntity p where p.id = :productId")
   Optional<ProductEntity> findLockById(@Param("productId") Long productId);
}
```

기존과 똑같이 nGrinder를 사용하여 테스트 해보자

<그림>


### 추후 고민 사항
1. 동시성 때문에 발생하는 상품 재고 문제
2. 주문 코드 중복 생성 문제
