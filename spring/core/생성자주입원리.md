우선 Bean 초기화부터 다시 보자

````java
public abstract class AbstractApplicationContext extends DefaultResourceLoader implements ConfigurableApplicationContext {
    
    @Override
    public void refresh() throws BeansException, IllegalStateException {
        ....
        // Register bean processors that intercept bean creation.
	registerBeanPostProcessors(beanFactory);
        ....
        // Initialize other special beans in specific context subclasses.
	onRefresh();
        ....
        // Instantiate all remaining (non-lazy-init) singletons.
	finishBeanFactoryInitialization(beanFactory);
    }
    
    protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
        ....
        // Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.
	String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
	for (String weaverAwareName : weaverAwareNames) {
		getBean(weaverAwareName);
	}
        
        // Instantiate all remaining (non-lazy-init) singletons.
	beanFactory.preInstantiateSingletons();
    }
}
````
PostProcessor 관련 Bean들이 제일 먼저 초기화되고, onRefresh를 통해 DispatcherServlet, Filter등 Servlet과 관련 Bean들이 초기화,
마지막 finishBeanFactoryInitialization을 통해 Non-Lazy한 모든 Singleton Bean들이 초기화 된다.

여기서 preInstantiateSingletons()를 조금더 보자. 
````java
DefaultListableBeanFactory.class

@Override
public void preInstantiateSingletons() throws BeansException {
  ....
  // Trigger initialization of all non-lazy singleton beans...
  for (String beanName : beanNames) {
    RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
    if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {
        ....
        getBean(beanName);
    }
  }
}  

AbstractBeanFactory.class

//---------------------------------------------------------------------
// Implementation of BeanFactory interface
//---------------------------------------------------------------------
@Override
public Object getBean(String name) throws BeansException {
	return doGetBean(name, null, null, false);
}

protected <T> T doGetBean(
    String name, @Nullable Class<T> requiredType, @Nullable Object[] args, boolean typeCheckOnly)
    throws BeansException {
    ....
    
    // Eagerly check singleton cache for manually registered singletons.
    Object sharedInstance = getSingleton(beanName);
    ....
    
    // Guarantee initialization of beans that the current bean depends on.
    String[] dependsOn = mbd.getDependsOn();
    if (dependsOn != null) {
       for (String dep : dependsOn) {
          ....
          registerDependentBean(dep, beanName);
          getBean(dep);
          ....
      }
    }
    
    // Create bean instance.
    if (mbd.isSingleton()) {
        sharedInstance = getSingleton(beanName, () -> {
            ....
            return createBean(beanName, mbd, args);
            ....
        }
        beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
    }
    
    return adaptBeanInstance(name, beanInstance, requiredType);
}
````
doGetBean() 메소드에서 getSingleton() 메소드를 통해 이미 생성되어있는 Bean이 있으면 가져오고 없다면 
createBean() 메소드를 통해 생성한다.

````java
AbstractAutowireCapableBeanFactory.class

@Override
protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
    throws BeanCreationException {
    ....
    Object beanInstance = doCreateBean(beanName, mbdToUse, args);
    ....
    return beanInstance;
}

protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
    throws BeanCreationException {
    // Instantiate the bean.
    BeanWrapper instanceWrapper = null;
    ....
    if (instanceWrapper == null) {
    	instanceWrapper = createBeanInstance(beanName, mbd, args);
    }
    ....
    populateBean(beanName, mbd, instanceWrapper);
    exposedObject = initializeBean(beanName, exposedObject, mbd);
    ....
    return exposedObject;
}
````
createBeanInstance() 메소드를 통해 인스턴스를 생성하고, 생성전략에 따른 의존성 주입이 진행된다.(생성자 주입, 팩토리메소드 주입)
이 후 popluateBean() 메소드을 통해 주입전략이 진행된다.(필드 주입, 메서드 주입)
initializeBean() 메소드를 통해 Bean 초기화를 진행합니다.
하나씩 보겠습니다.

````java
AbstractAutowireCapableBeanFactory.class

protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) {
    ....
    // Candidate constructors for autowiring?
    Constructor<?>[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
    if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||
    		mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) {
    	return autowireConstructor(beanName, mbd, ctors, args);
    }
   ....
}

@Nullable
protected Constructor<?>[] determineConstructorsFromBeanPostProcessors(@Nullable Class<?> beanClass, String beanName)
	throws BeansException {

    if (beanClass != null && hasInstantiationAwareBeanPostProcessors()) {
	for (SmartInstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().smartInstantiationAware) {
    	    Constructor<?>[] ctors = bp.determineCandidateConstructors(beanClass, beanName);
    	    if (ctors != null) {
    	    	return ctors;
    	    }
    	}
    }
    return null;
}

protected BeanWrapper autowireConstructor(
    String beanName, RootBeanDefinition mbd, @Nullable Constructor<?>[] ctors,      @Nullable Object[] explicitArgs) {
    return new ConstructorResolver(this).autowireConstructor(beanName, mbd, ctors, explicitArgs);
}
````
생성 메소드 순서를 다시 보자면
getBean() -> doGetBean() -> createBean() -> doCreateBean() -> createBeanInstance()
위 순서대로 Bean을 생성합니다.
determineConstructorsFromBeanPostProcessors() 메소드를 통해 생성자를 구합니다.
조건을 만족하면 생서장 주입을 합니다.


