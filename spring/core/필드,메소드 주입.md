````java
AbstractAutowireCapableBeanFactory.class

protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) {
  .... 
  // Candidate constructors for autowiring?
    Constructor<?>[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
    if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||
    	  mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) {
    	return autowireConstructor(beanName, mbd, ctors, args);
    }
  ....
  if (mbd.getFactoryMethodName() != null) {
	return instantiateUsingFactoryMethod(beanName, mbd, args);
  }
  ....
  return instantiateBean(beanName, mbd);
}

protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
			throws BeanCreationException {
  // Instantiate the bean.
  BeanWrapper instanceWrapper = null;
  ....
  if (instanceWrapper == null) {
	instanceWrapper = createBeanInstance(beanName, mbd, args);
  }
  Object bean = instanceWrapper.getWrappedInstance();
  ....
  // Initialize the bean instance.
	Object exposedObject = bean;
  try {
  	populateBean(beanName, mbd, instanceWrapper);
  	exposedObject = initializeBean(beanName, exposedObject, mbd);
  }
  ....
}
````
생성자 주입이 아닌 경우 instantiateBean() 메소드를 통해 의존성 주입이 되지 않은 상태로 빈을 생성한다.
populateBean(), initializeBean() 메소드를 통해 의존성을 주입한다.

본격적으로 필드주입과 메소드주입을 보자
````java
AbstractAutowireCapableBeanFactory.class

protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {
  ....
  for (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) {
  	PropertyValues pvsToUse = bp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);
  	if (pvsToUse == null) {
  		if (filteredPds == null) {
  			filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
  		}
  		pvsToUse = bp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
  		if (pvsToUse == null) {
  			return;
  		}
  	}
  	pvs = pvsToUse;
  }
  ....
}
````
for문을 통해 InstantiationAwareBeanPostProcessor 인터페이스 구현체인 AutowiredAnnotationBeanPostProcessor 클래스를 통해
postProcessProperties() 메소드를 호출합니다.
````java
AutowiredAnnotationBeanPostProcessor.class

@Override
public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {
  InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);
  try {
  	metadata.inject(bean, beanName, pvs);
  }
  catch (BeanCreationException ex) {
  	throw ex;
  }
  catch (Throwable ex) {
  	throw new BeanCreationException(beanName, "Injection of autowired dependencies failed", ex);
  }
  return pvs;
}

private InjectionMetadata findAutowiringMetadata(String beanName, Class<?> clazz, @Nullable PropertyValues pvs) {
  ....
  InjectionMetadata metadata = this.injectionMetadataCache.get(cacheKey);
  ....
  metadata = buildAutowiringMetadata(clazz);
  ....
  return metadata;
}

private InjectionMetadata buildAutowiringMetadata(Class<?> clazz) {
  if (!AnnotationUtils.isCandidateClass(clazz, this.autowiredAnnotationTypes)) {
  	return InjectionMetadata.EMPTY;
  }

  List<InjectionMetadata.InjectedElement> elements = new ArrayList<>();
  Class<?> targetClass = clazz;

  do {
    final List<InjectionMetadata.InjectedElement> currElements = new ArrayList<>();

    ReflectionUtils.doWithLocalFields(targetClass, field -> {
    	MergedAnnotation<?> ann = findAutowiredAnnotation(field);
    	if (ann != null) {
    	  if (Modifier.isStatic(field.getModifiers())) {
    	  	if (logger.isInfoEnabled()) {
    	  		logger.info("Autowired annotation is not supported on static fields: " + field);
    	  	}
    	  	return;
    	  }
    	  boolean required = determineRequiredStatus(ann);
    	  currElements.add(new AutowiredFieldElement(field, required));
    	}
    });

    ReflectionUtils.doWithLocalMethods(targetClass, method -> {
    	Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);
    	if (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) {
    		return;
    	}
    	MergedAnnotation<?> ann = findAutowiredAnnotation(bridgedMethod);
    	if (ann != null && method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) {
    	  if (Modifier.isStatic(method.getModifiers())) {
    	  	if (logger.isInfoEnabled()) {
    	  		logger.info("Autowired annotation is not supported on static methods: " + method);
    	  	}
    	  	return;
    	  }
    	  if (method.getParameterCount() == 0) {
    	  	if (logger.isInfoEnabled()) {
    	  		logger.info("Autowired annotation should only be used on methods with parameters: " + method);
    	  	}
    	  }
    	  boolean required = determineRequiredStatus(ann);
    	  PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);
    	  currElements.add(new AutowiredMethodElement(method, required, pd));
    	}
    });

    elements.addAll(0, currElements);
    targetClass = targetClass.getSuperclass();
  }
  while (targetClass != null && targetClass != Object.class);

  return InjectionMetadata.forElements(elements, clazz);
}
````
