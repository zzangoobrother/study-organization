````java
public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(BeanConfiguration.class);
    TestBean testBean = (TestBean) ctx.getBean("testBean");
    System.out.println(testBean.getName());

    SpringApplication.run(ToyBoardProjectApplication.class, args);
}

@Configuration
class BeanConfiguration {
    @Bean
    public TestBean testBean() {
        return new TestBean();
    }
}

class TestBean {
    public String name = "test";

    public String getName() {
        return this.name;
    }
}
````
Annotation 기반 컨텍스트를 생성했다.
그리고 getBean() 메소드를 통해 TestBean을 가져온다.
getBean() 메소드가 어디서 구현되는지 보자
AnnotationConfigApplicationContext 클래스의 UML을 보자
![캡처123456](https://user-images.githubusercontent.com/42162127/233660091-d3f22cfe-3d21-4c7c-b42e-7db1fc2f4d9f.PNG)

UML을 보면 getBean() 메소드를 가지고 있는 BeanFactory를 상속받는 클래스를 찾으면 GenericApplicationContext 클래스이다.
GenericApplicationContext 클래스에는 getBean() 메소드 구현이 없다.
그러면 AbstractApplicationContext 추상 클래스에 가면 있다.
````java
@Override
public Object getBean(String name) throws BeansException {
	assertBeanFactoryActive();
	return getBeanFactory().getBean(name);
}
````
getBeanFactory() 메소드를 보자

````java
@Override
public abstract ConfigurableListableBeanFactory getBeanFactory() throws IllegalStateException;
````
abstract 메소드로 하위 클래스에서 구현한다. 하위 클래스는 GenericApplicationContext 이다.
````java
@Override
public final ConfigurableListableBeanFactory getBeanFactory() {
	return this.beanFactory ;
}
````
beanFactory 변수는

````java
private final DefaultListableBeanFactory beanFactory;
````
DefaultListableBeanFactory 타입이다.

````java
public class DefaultListableBeanFactory extends AbstractAutowireCapableBeanFactory
		implements ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable {
	@Override
	public <T> T getBean(Class<T> requiredType) throws BeansException {
		return getBean(requiredType, (Object[]) null);
	}
	
	@Override
	public <T> T getBean(Class<T> requiredType, @Nullable Object... args) throws BeansException {
		Assert.notNull(requiredType, "Required type must not be null");
		Object resolved = resolveBean(ResolvableType.forRawClass(requiredType), args, false);
		if (resolved == null) {
			throw new NoSuchBeanDefinitionException(requiredType);
		}
		return (T) resolved;
	}
	
	@Nullable
	private <T> T resolveBean(ResolvableType requiredType, @Nullable Object[] args, boolean nonUniqueAsNull) {
		NamedBeanHolder<T> namedBean = resolveNamedBean(requiredType, args, nonUniqueAsNull);
		if (namedBean != null) {
			return namedBean.getBeanInstance();
		}
		BeanFactory parent = getParentBeanFactory();
		if (parent instanceof DefaultListableBeanFactory dlfb) {
			return dlfb.resolveBean(requiredType, args, nonUniqueAsNull);
		}
		else if (parent != null) {
			ObjectProvider<T> parentProvider = parent.getBeanProvider(requiredType);
			if (args != null) {
				return parentProvider.getObject(args);
			}
			else {
				return (nonUniqueAsNull ? parentProvider.getIfUnique() : parentProvider.getIfAvailable());
			}
		}
		return null;
	}
	
	@Nullable
	private <T> NamedBeanHolder<T> resolveNamedBean(
			ResolvableType requiredType, @Nullable Object[] args, boolean nonUniqueAsNull) throws BeansException {

		Assert.notNull(requiredType, "Required type must not be null");
		String[] candidateNames = getBeanNamesForType(requiredType);

		if (candidateNames.length > 1) {
			List<String> autowireCandidates = new ArrayList<>(candidateNames.length);
			for (String beanName : candidateNames) {
				if (!containsBeanDefinition(beanName) || getBeanDefinition(beanName).isAutowireCandidate()) {
					autowireCandidates.add(beanName);
				}
			}
			if (!autowireCandidates.isEmpty()) {
				candidateNames = StringUtils.toStringArray(autowireCandidates);
			}
		}

		if (candidateNames.length == 1) {
			return resolveNamedBean(candidateNames[0], requiredType, args);
		}
		else if (candidateNames.length > 1) {
			Map<String, Object> candidates = CollectionUtils.newLinkedHashMap(candidateNames.length);
			for (String beanName : candidateNames) {
				if (containsSingleton(beanName) && args == null) {
					Object beanInstance = getBean(beanName);
					candidates.put(beanName, (beanInstance instanceof NullBean ? null : beanInstance));
				}
				else {
					candidates.put(beanName, getType(beanName));
				}
			}
			String candidateName = determinePrimaryCandidate(candidates, requiredType.toClass());
			if (candidateName == null) {
				candidateName = determineHighestPriorityCandidate(candidates, requiredType.toClass());
			}
			if (candidateName != null) {
				Object beanInstance = candidates.get(candidateName);
				if (beanInstance == null) {
					return null;
				}
				if (beanInstance instanceof Class) {
					return resolveNamedBean(candidateName, requiredType, args);
				}
				return new NamedBeanHolder<>(candidateName, (T) beanInstance);
			}
			if (!nonUniqueAsNull) {
				throw new NoUniqueBeanDefinitionException(requiredType, candidates.keySet());
			}
		}

		return null;
	}
}
````
흐름을 보면 getBean -> getBean -> resolveBean -> resolveNamedBean 메소드로 가는걸 볼수 있다.

