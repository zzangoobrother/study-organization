## TDD kotlin 버전, 간단한 회원가입

나는 주로 TDD를 통해 개발을 하면 
인수테스트 -> controller 테스트 -> service 테스트 -> 경우에 따라 repository 테스트
순으로 TDD를 작성하며 개발한다.

### 인수테스트
인수테스트는 시나리오 테스트라고도 볼 수 있는데 만약 게시글을 등록을 한다면
회원가입 -> 로그인 -> 게시글 등록
의 순서처럼 시나리오를 가지는 테스트이다.

인수테스트를 먼저 작성하는 이유는 내가 최종적으로 만들고자 하는 api의 결과를 알기위한 수단이라고 생각하면 된다.
인수테스트 예제는 나중에 추가 하도록 하겠다. 

### controller 테스트
controller 테스트를 하는 여러방법이 있지만 나는 mock를 활용하여 테스트를 한다.
내가 생각하는 controller 테스트에서 봐야하는 사항은 
controller 앞단에 있는 security나 filter도 검사해야 한다고 생각한다.
우선 내가 작성한 예제를 보자

````java
@WebMvcTest(UserController::class)
class UserControllerTest {

    @Autowired
    private lateinit var mockMvc: MockMvc

    @Autowired
    private lateinit var objectMapper: ObjectMapper

    @MockkBean
    private lateinit var userService: UserService

    @Test
    fun `회원가입을 한다`() {
        val request = SignupRequest(
            loginId = "abcd",
            password = "1234"
        )

        every { userService.signup(request) } just Runs

        mockMvc.post("/signup") {
            content = objectMapper.writeValueAsString(request)
            contentType = MediaType.APPLICATION_JSON
        }
            .andDo { print() }
            .andExpect {
                status { isCreated() }
            }
    }
}

data class SignupRequest(
    @field: NotBlank
    val loginId: String,

    @field: NotBlank
    val password: String
) {
}

@RestController
class UserController(
    private val userService: UserService
) {

    @ResponseStatus(HttpStatus.CREATED)
    @PostMapping("/signup")
    fun signup(@Valid @RequestBody request: SignupRequest) {
        userService.signup(request)
    }
}
````

간단한 예제이다. 로그인 id와 비밀번호만 가지는 예제이다.
테스트 코드를 보면 @WebMvcTest(UserController::class) 를 설정했는데
@SpringBootTest 를 사용할 수 있지만 지금 내가 사용한 MockMvc를 사용하기 위해
@AutoConfigureMockMvc 를 사용하여야 하고, @Service, @Repository 까지 메모리에 올려
테스트 하기에 내가 하고자하는 테스트와 맞지 않다.
@WebMvcTest 는 @RestController, @ControllerAdvice 등을 사용가능하고,
간단한 controller 테스트에 적합하다.

### service 테스트
service 테스트는 주로 Fake 객체를 만들어 테스트 한다.
주로 개발을 할때 바로 DB와 연결된 repository를 의존받지 않고 중간에 중간 계층을 하나 두어 필요한 기능만 하게 한다.
````java
@Service
class UserService(
    private val userRepository: UserRepository
) {

    fun signup(request: SignupRequest) {
        val user = UserEntity(request.loginId, request.password)
        userRepository.create(user);
    }
}

interface UserRepository {
    fun create(user: UserEntity)
}

@Repository
class UserRepositoryImpl(
    private val jpaUserRepository: JpaUserRepository
) : UserRepository {

    override fun create(user: UserEntity) {
        jpaUserRepository.save(user)
    }
}

interface JpaUserRepository : JpaRepository<UserEntity, Long> {
}
````

service는 중간 UserRepository 인터페이스를 의존받고 UserRepository 구현체에서 DB의 JpaUserRepository 를 의존받아 구현한다.
이런 구조를 가지만 테스트하기 훨씬 편해진다.

Fake 객체는 UserRepository 인터페이스를 상속받아 가짜 구현체를 만든다.
````java
class FakeUserRepository : UserRepository {

    private val autoGeneratedId: AtomicLong = AtomicLong(0)
    private val users: ArrayList<UserEntity> = ArrayList()

    override fun create(user: UserEntity) {
        if (user.id == null) {
            UserEntity(
                id = autoGeneratedId.incrementAndGet(),
                loginId = user.loginId,
                password = user.password
            )
            users.add(user)
            return
        }

        users.removeIf { u -> u.id == user.id }
        users.add(user)
    }

}
````

테스트에서 가짜 구현체를 주입받고 회원가입 테스트를 하면 된다.
