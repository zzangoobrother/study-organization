### 객체 분해

- 추상화 : 불필요한 정보를 제거하고 현재의 문제 해결에 필요한 핵심만 남기는 작업
- 분해 : 큰 문제를 해결 가능한 작은 문제로 나누는 작업

#### 프로시저 추상화와 데이터 추상화
- 프로시저 추상화(procedure abstraction) : 소프트웨어가 무엇을 해야 하는지를 추상화, 프로시저를 이용해 데이터를 조작
- 데이터 추상화(data abstraction) : 데이터 추상화는 소프트웨어가 무엇을 알아야 하는지를 추상화, 데이터를 이용해 정보를 표현

즉, 소프트웨어는 데이터를 이용해 정보를 표현하고 프로시저를 이용해 데이터를 조작한다.

- 프로시저 추상화 중심으로 시스템 분해를 결정했다면 '기능 분해'
- 데이터 추상화를 중심으로 시스템을 분해를 결정했다면
  - 타입을 추상화, 추상 데이터 타입이라고 부름
  - 프로시저를 추상화, 객체지향이라 부름

객체지향 : 역할과 책임을 수행하는 자율적인 객체들의 협력 공동체를 구축하는 것, 데이터 추상화와 프로시저 추상화를 함께 포함한 클래스를 이용해 시스템을 분해하는 것

#### 프로시저 추상화와 기능 분해
##### 메인 함수로서의 시스템
프로시저를 추상화라 부르는 이유 : 내부의 상세한 구현 내용을 모르더라도 인터페이스만 알면 프로시저 사용 가능, 잠재적으로 정보은닉 가능성 제시, 하지만 한계 존재

##### 급여 관리 시스템
하향식 접근법은 최상위의 추상적인 함수 정의에서 출발, 단계적인 정제 절차를 따라 시스템 구축

```txt
직원의 급여를 계산한다.
```

세부적인 절차로 구체화

```txt
직원의 급여를 계선한다.
   - 사용자로부터 소득세율을 입력받는다.
   - 직원의 급여를 계산한다.
   - 양식에 맞게 결과를 출력한다.
```

급여 계산을 위한 모든 절차

```txt
직원의 급여를 계선한다.
   - 사용자로부터 소득세율을 입력받는다.
     - "세율을 입력하세요: " 라는 문장을 화면에 출력한다.
     - 키보드를 통해 세율을 입력받는다.
   - 직원의 급여를 계산한다.
     - 전역 변수에 저장된 직원의 기본급 정보를 얻는다.
     - 급여를 계산한다
   - 양식에 맞게 결과를 출력한다.
     - "이름: {직원명}, 급여: {계산된 금액}" 형식에 따라 출력 문자열을 생성한다.
```

##### 급여 관리 시스템 구현
<table>
<tr>
<th>문장</th>
<th>함수 정의</th>
</tr><tr>
<td>
직원의 급여를 계산한다.
</td>

<td>

```ruby
def main(name)
end
```

</td>
</tr><tr>
<td>
직원의 급여를 계산한다.

  사용자로부터 소득세율을 입력받는다
  
  직원의 급여를 계산한다.

  양식에 맞게 결과를 출력한다.
</td>

<td>

```ruby
def main(name)
  taxRate = getTaxRate()
  pay = calculatePayFor(name, taxRate)
  puts(describeResult(name, pay))
end
```

</td>
</tr><tr>
<td>
직원의 급여를 계산한다.

  사용자로부터 소득세율을 입력받는다
    "세율을 입력하세요: "라는 문장을 화면에 출력한다
    키보드를 통해 세율을 입력받는다.
  직원의 급여를 계산한다.

  양식에 맞게 결과를 출력한다.
</td>

<td>

```ruby
def getTaxRate()
  print("세율을 입력하세요: ")
  return gets().chomp().to_f()
end
```

</td>
</tr><tr>
<td>
직원의 급여를 계산한다.
  사용자로부터 소득세율을 입력받는다
    "세율을 입력하세요: "라는 문장을 화면에 출력한다
    키보드를 통해 세율을 입력받는다.
  직원의 급여를 계산한다.
    전역 변수에 저장된 직원의 기본급 정보를 얻는다
    급여를 계산한다.

  양식에 맞게 결과를 출력한다.
</td>

<td>

```rudy
$employees = ["직원A", "직원B", "직원C"]
$basePays = [400, 300, 250]

def calculatePayFor(name, taxRate)
  index = $employees.index(name)
  basePay = $basePays[index]
  return basePay - (basePay * taxRate)
end
```

</td>
</tr><tr>
<td>
직원의 급여를 계산한다.
  사용자로부터 소득세율을 입력받는다
    "세율을 입력하세요: "라는 문장을 화면에 출력한다
    키보드를 통해 세율을 입력받는다.
  직원의 급여를 계산한다.
    전역 변수에 저장된 직원의 기본급 정보를 얻는다
    급여를 계산한다.

  양식에 맞게 결과를 출력한다.
    "이름: {직원명}, 급여: {계산된 금액}" 형식에 따라 출력 문자열을 생성한다.
</td>

<td>

```ruby
def describeResult(name, pay)
  return "이름: #{name}, 급여: #{pay}"
end
```

</td>
</tr>
</table>

##### 하향식 기능 분해의 문제점
직면하는 문제점
- 시스템은 하나의 메인 함수로 구성돼 있지 않다.
- 기능 추가나 요구사항 변경으로 인해 메인 함수를 빈번하게 수정해야 한다.
- 비즈니스 로직이 사용자 인터페이스와 강하게 결합된다.
- 하향식 분해는 너무 이른 시기에 함수들의 실행 순서를 고정시키기 때문에 유연성과 재사용성이 저하된다.
- 데이터 형식이 변경될 경우 파급효과를 예측할 수 없다.

1. 하나의 메인 함수라는 비현실적인 아이디어
대부분의 시스템에서 하나의 메인 기능이란 개념은 존재하지 않는다.

'실제 시스템에 정상이란 존재하지 않는다.' - 버트란드 마이어

2. 메인 함수의 빈번한 재설계
시스템은 여러 개의 정상으로 구성되기 때문에 새로운 정상을 추가할 때마다 하나의 정상이라고 간주했던 내부 구현을 수정할 수밖에 없다.
결과적으로 기존 코드의 빈번한 수정으로 버그 발생 확률이 높아지고, 시스템은 변경에 취약해질 수밖에 없다.

3. 비즈니스 로직과 사용자 인터페이스의 결합

