PriorityQueue와 TreeMap 비교

### PriorityQueue
PriorityQueue는 Heap 자료구조로 되어있습니다.
Heap 자료구조는 최소값, 최대값을 찾기위해 완전 이진 트리를 사용합니다.
최소힙은 root 노드가 제일 작으며 부모 노드는 자식 노드보다 항상 작습니다.
Heap 생성 알고리즘을 Heapify 알고리즘이라고 합니다.

### TreeMap
TreeMap은 레드-블랙 트리 자료구조로 되어있습니다. 이진탐색트리의 문제점을 보완한 트리입니다.
이진탐색트리의 문제점인 한쪽으로 쳐진다면 최악의 경우 O(N)의 시간복잡도를 가집니다. 이를 보완하기 위해 레드-블랙 트리가 등장했습니다.
데이터를 넣을때와 뺄때 Restructuring과 Recoloring 추가 프로세스로 진행하여 균형을 맞춥니다.
루트부터 리프노드까지 블랙 노드 갯수는 같다 라는 것을 기조로 합니다.
레드-블랙 트리의 조건을 맞추면 루트부터 리프까지 최소길이와 최대길이의 차이가 2배 이하로 됩니다.

### 공통점
공통점은 이진 트리 구조라는게 전부 입니다.

### 차이점
1. 탐색 속도
- PriorityQueue
최대값 또는 최소값 데이터를 확인하는데 O(1)의 시간이 걸립니다.
가져올때는 heapify가 필요하기 때문에 O(logN)이 걸립니다.
그리고 삽입 및 삭제도 O(logN)의 시간이 걸립니다.
특정 데이터를 탐색하는데는 O(N)이 걸립니다.

- TreeMap
최대값, 최소값 데이터를 확인하는데 O(1)이 걸립니다.
데이터를 가져오는데 O(logN)이 걸립니다.
삽입, 삭제도 O(logN)의 시간이 걸립니다.
특히 데이터를 탐색하는데 전체적인 정렬 상태이기에 O(logN)의 시간이 걸립니다.

### 사용하는 곳
- PriorityQueue
최대값, 최소값을 찾는데 사용합니다. O(1)의 시간을 가지며 다시 Heapify하는데 O(logN)의 시간이 걸리므로
결과적으로 O(logN)의 시간이 걸립니다.

- TreeMap
특정 key를 기준으로 사전순으로 정렬된 데이터를 가져올 때 사용합니다.
key를 기준으로 특정 데이터를 가져오는데 사용됩니다.

### 데이터 저장 구조
- PriorityQueue
이진 트리 구조입니다. 최소힙이면 부모는 자식 노드보다 항상 작고, 최대힙이면 부모는 자식 노드보다 항상 큽니다.

- TreeMap
이진 트리 구조입니다. 부모 노드는 항상 왼쪽 자식보다 크며, 오른쪽 자식보다 작습니다.
key의 중복은 안되며, 키가 중복된다면 기존 값을 교체합니다.

### 구현 방법
- PriorityQueue
배열로 구현되어 있습니다. root는 0번째 배열입니다. 왼쪽 자식은 부모노드 * 2, 오른쪽 자식은 (부모노드 * 2) + 1번째 노드를 유지합니다.
배열로 되어있기 때문에 노드간의 이동에 오버헤드가 적습니다.

- TreeMap
객체간 참조로 구현되어 있습니다.
노드 객체 안에 또 다른 노드로 parent, left, right를 구현한 후 연결하는 형식입니다.
노드간 이동에 PriorityQueue 보다 오버헤드가 있습니다.
