## 19. item13 clone 재정의는 주의해서 진행하라

- clone 규약
  - x.clone() != x 반드시 true, 객체 주소가 달라야 한다.
  - x.clone().getClass() == x.getClass() 반드시 true
  - x.clone().equals(x) true가 아닐 수도 있다.
- 불변 객체라면
  - Cloenable 인터페이스를 구현하고, clone 메서드를 재정의한다. 이때 super.clone()을 사용해야 한다.
 
clone() 메소드를 재정의 하면 기본적으로
````java
@Override
protected Object clone() throws CloneNotSupportedException {
  return super.clone();
}
````
위 코드처럼 되지만 checked exception을 upchecked exception으로 바꿔주고 리턴 타입을 본인의 타입을 바꿔 주면 사용하기 편하다.
````java
@Override
protected 본인 타입 clone() {
  try {
    return (본인 타입) super.clone();
  } catch (CloneNotSupportedException e) {
    throw new AssertionError();
  } 
}
````

colne() 메서드에 대한 의문은 왜 super.clone() 일까이다. 
new 를 사용하여 객체를 새로 생성해도 괜찮지 않을까? 의문이 생길 수 있다.
코드를 보자.

````java
public class Item implements Cloneabel {
  private String name;

  @Override
  public Item clone() {
    Item item = new Item();
    item.name = this.name;
    return item;
  }
}

public class SubItem extends Item implements Cloneable {
  private String name;

  @Override
  public SubItem clone() {
    return (SubItem) super.clone();
  }
}

public static void main(String[] args) {
  SubItem item = new SubItem();
  SubItem clone = item.clone();

  System.out.println(clone != item);
  System.out.println(clone.getClass() == item.getClass());
  System.out.println(clone.equals(item));
}
````
위 코드를 실행하면 SubItem clone = item.clone(); 여기에서 exception이 발생한다. 
원인은 상위 clone() 메소드는 item을 리턴하고 SubItem clone() 메소드에서 타입 캐스팅을 하는데
하위 타입에서 상위 타입으로 타입 캐스팅은 가능하지만 상위 타입을 하위 타입으로 타입 캐스팅을 하지 못하기 때문에 에러가 발생한다.

만약 SubItem 에서 clone 메서드를 재정의 안한다면
````java
public class Item implements Cloneabel {
  private String name;

  @Override
  public Item clone() {
    Item item = new Item();
    item.name = this.name;
    return item;
  }
}

public class SubItem extends Item implements Cloneable {
  private String name;
}

public static void main(String[] args) {
  SubItem item = new SubItem();
  SubItem clone = (SubItem) item.clone();

  System.out.println(clone != item);
  System.out.println(clone.getClass() == item.getClass());
  System.out.println(clone.equals(item));
}
````
SubItem clone = (SubItem) item.clone(); 여기서 에러가 발생한다. 이유는 같다. 상위 타입을 하위 타입으로 캐스팅 하기 때문에 에러가 발생한다.

제대로 new 를 사용하지 않고 clone 메소드를 작성하고 실행 하면
````java
public class Item implements Cloneabel {
  private String name;

  @Override
  public Item clone() {
    try {
      return (Item) super.clone();
    } catch (CloneNotSupportedException e) {
      throw new AssertionError();
    } 
  }
}

public class SubItem extends Item implements Cloneable {
  private String name;
}

public static void main(String[] args) {
  SubItem item = new SubItem();
  SubItem clone = (SubItem) item.clone();

  System.out.println(clone != item);
  System.out.println(clone.getClass() == item.getClass());
  System.out.println(clone.equals(item));
}
````
결과는 
true
true
false
로 출력된다.
하위 타입의 객체로 clone을 호출하면 하위 타입으로 리턴하게 된다.
그리고 하위 타입에서 clone 을 재정의 하면
````java
public class Item implements Cloneabel {
  private String name;

  @Override
  public Item clone() {
    try {
      return (Item) super.clone();
    } catch (CloneNotSupportedException e) {
      throw new AssertionError();
    } 
  }
}

public class SubItem extends Item implements Cloneable {
  private String name;

  @Override
  public SubItem clone() {
    return (SubItem) super.clone();
  }
}

public static void main(String[] args) {
  SubItem item = new SubItem();
  SubItem clone = item.clone();

  System.out.println(clone != item);
  System.out.println(clone.getClass() == item.getClass());
  System.out.println(clone.equals(item));
}
````
결과는 같다.

결론은 super.clone() 이 코드를 어디서 호출하느냐에 따라 리턴되는 타입이 다르게 나온다.

