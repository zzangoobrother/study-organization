## static

#### static은 무엇인가?
static은 고정된 이라는 의미로 static변수, static메소드로 사용할 수 있습니다.
static으로 설정을 하면 메모리 영역에서 객체들의 영역인 heap 영역에 있는게 아니라 메소드 영역에 있게 됩니다. 
그리고 클래스 로더가 클래스를 로딩해서 메소드 메모리 영역에 적재할때 관리됩니다. 클래스 로딩이 끝나면 즉시 사용할 수 있습니다.
메소드 영역은 메모리의 모든 객체가 공유 할 수 있는 공간입니다.
하지만 GC관리 영역 밖이라 프로그램 종료시까지 메모리가 할당된 채로 존재합니다. 그렇기 때문에 너무 남용하면 시스템에 영향을 줄 수 있습니다.
그리고 공용으로 사용하기 때문에 static변수에 상태값을 저장하고 사용한다면 서로 다른 클라이언트이 의도하지 않은 값을 얻어 잘못된 데이터를 가질 수 있습니다.

#### 멀티쓰레드 환경에서의 static
멀티쓰레드 환경에서 static 변수를 공유하면 원하지 않은 값이나 틀린 값을 가지게 되어 오류가 발생할 수 있다.
이 문제를 해결하기 위해 자바에서는 synchronized 를 이용하여 해결할 수 있다.
하지만 synchronized 사용 시 다른 쓰레드들이 기다려야되어 동시성이 저하될 수 있다는 점과
해당 방식이 non-blocking 한 방식이 아니라 blocking 한 방식이므로 데드락 문제가 발생할 수 있다.
또 자바5 부터는 synchronized 대신 java.util.concurrent 패키지에서 제공하는 Lock 인터페이스와 condition 인터페이스를 
사용하여 더 유연하게 동기화를 구현할 수 있다.

Lock 인터페이스를 사용하면 어떤 스레드가 먼저 락을 획득하게 될지 순서를 지정할 수 있다. synchronized는 어떤 스레드가 획득할 지
순서를 보장하지 않아 스레드가 기아 상태가 될 수 있다.
하지만 java 5부터 synchronized에 대한 개선이 이루어져서 적극적인 대기를 통해 락을 획득하는 FIFO 정책이 도입되었다.
따라서 synchronized 에서도 데드락이나 기아 문제를 해결할 수 있다.

멀티 스레드 프로그래밍에서 데드락(Deadlock)은 하나 이상의 스레드가 서로 락(Lock)을 획득하려고 하면서 무한 대기 상태에 빠지는 
상황을 말한다. 이를 발생시키는 상황에는 세 가지 필요조건이 있다.

1. 상호배제(Mutual Exclusion) : 리소스는 한 번에 한 프로세스 또는 스레드만 사용할 수 있습니다. 다른 프로세스 또는 스레드가 해당 리소스에 접근할 수 없게 잠금(Lock)을 걸게 되는데 이때 다른 프로세스 또는 스레드는 대기해야합니다.

2. 점유 및 대기(Hold and Wait) : 프로세스 또는 스레드가 이미 점유한 리소스를 유지한 채로 다른 리소스를 요청하면서 대기하는 상황입니다. 다른 리소스를 요청하면서 대기하는 동안 이미 점유한 리소스는 해제하지 않습니다.

3. 비선점(Non-Preemptive) : 다른 프로세스 또는 스레드는 이미 점유한 리소스를 강제로 선점할 수 없습니다. 리소스를 점유한 프로세스 또는 스레드가 직접 해당 리소스를 해제해야합니다.

이러한 조건이 모두 충족될 때 데드락이 발생한다. 일반적으로 데드락이 발생하기 어려운 상황에도 데드락이 발생할 가능성이 있는 경우도 있다.
- 리소스 접근 순서 문제(경쟁상황)
- 무분별한 리소스 할당
- 상호배제 불가능 한 경우 등

데드락이 발생하게 되면 해당 스레드의 작업이 멈추기 때문에 시스템의 전체적인 성능이 저하되며 데드락의 원인을 찾기도 어렸습니다.
따라서 데드락이 발생하지 않도록 프로그래밍 할 때 가능한 순환참조 사이클 제거, 임계영역(critical section)의 크기를 줄이고,
리소스 할당 순서를 관리하는 등의 방법으로 예방해야 한다.
