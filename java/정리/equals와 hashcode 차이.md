# Equals와 Hashcode 차이

equals는 동일한 객체인지 여부를 판단합니다. hashcode는 객체의 고유한 정수형값을 반환하며

동일한 객체라면 항상 같은 hashcode를 반환합니다. 객체의 동등성 비교에 사용합니다.

hashcode의 기본 구현은 객체의 메모리주소를 사용하지만, hashcode를 오버라이딩하여 객체의 동등성 비교에 사용하는 경우

hashcode 값을 객체가 가지고 있는 값들의 해시값으로 생성하여 사용합니다.

이때 equals 메서드 역시 오버라이딩하여 객체의 값들을 비교합니다.

그러므로 객체의 값들이 같으면 동일한 hashcode 값을 가지도록 구현해야 합니다.

객체 비교는 hashcode 값을 먼저 비교 후 hashcode가 같으면 equals 메서드를 통해 동등한 객체인지 비교를 합니다.

만약 equals만 재정의를 한다면 동등한 객체라도 hashcode 값이 다르게 나올수 있기에 hashcode와 equals 메서드를 같이 재정의 합니다.

#### hashcode 생성시 어떤 알고리즘이나 규칙을 지켜야 하나요?
Division Method: 저장소의 크기로 나누어 나온 나머지를 사용 

Digit Folding: 문자열을 아스키코드로 바꾸고 그 값을 합해 사용

Multiplication Method: 숫자로 된 key값 k, 0~1 사이의 실수 A, 2의 제곱수 M 을 사용하여 계산 (kA mod 1)m

Univeral Hashing: 다수의 hash 함수를 만들어 특정한 장소에 넣어 무작위로 hash 함수를 선택해 사용

해시충돌이 일어난다면 대체방안 중 하나로 체이닝이 있습니다. 어떤 방식으로 처리하나요?

같은 해시끼리의 공간을 연결리스트로 저장합니다. 즉 LinkedList를 사용하여 데이터를 저장합니다.

하지만 시간복잡도가 해시 함수에 따라 최악의 경우 O(n)의 시간복잡도를 가질 수 있습니다.

모든 객체의 해시값이 같다면 최악의 경우 O(n) 시간복잡도를 가집니다. 이를 개선하기 위해

Linear probing: 해시충돌이 발생하면 다음 버킷으로 이동하여 저장을 합니다.

Quadratic probing : 제곱수로 늘어납니다. 처음 충돌이 나면 1^2, 두번째 충돌은 2^2, 세번째 3^2 만큼의 폭으로 값을 옮깁니다.

Dobule hashing: 해시값의 규칙성을 없애버려서 충돌을 방지하는 기법

위와 같은 기법을 사용합니다.

Dobule hashing에 대해 추가 설명을 하면, 2개의 해시함수를 사용하는데 하나의 해시함수를 사용하다가

충돌이 발생하면, 처음 해시함수와 다른 해시함수로 다시 해시값을 만들고 비교를 합니다.

효율은 다른 충돌 방식에 비해 좋지 않고, 많은 연산량을 요구합니다.

Dobule hashing에 특징과 성능에 대해 더 말하자면, 충돌이 생기면 다음 주소를 계산할 때 두번째 해시값 만큼 점프를 합니다. 

여기서 Double Hashing의 주의점은 두번째 해시값이 해시테이블 크기와 서로소인 값이어야 합니다. 좋은 해시함수를 만드는 조건은

1. key를 고르게 분포시킬 수 있어야 한다.
2. 
3. 충돌 발생 빈도가 적어야 한다.
4. 
5. 빠른 연산이 가능해야 한다.

해시함수를 구현할 때 자주 사용되는 해시 함수 MD5와 SHA의 동작 방식과 해시 함수 충돌시 어떤 조치를 취하나요?

MD5 : 메시지 축약 알고리즘, 파일의 무결성 용도로 사용된다. 128비트의 해시 함수를 이용해 암호화, 복호화를 한다. MD5의 결함을 발견하고 SHA 사용을 권장한다.

SHA : 안전한 해시 알고리즘, 여러 종류가 존재하며 그중 SHA-1은 SHA 함수 중 가장 많이 사용된다. TLS, SSL, PGP, SSH 등 많은 보안 프로토콜과 프로그램에서 사용된다. 

눈사태 효과로 인해 해시값 변동이 아주 크다. 

개방형 주소 지정(Open Addressing) : 데이터를 삽입하려는 해시 버킷이 이미 사용 중인 경우 다른 해시 버킷에 해당 데이터를 삽입하는 방식

개별 연결(Separate Chaining) : 자바에서 사용하는 방식, 동일한 해시값을 가지면 연결 리스트로 연결한다.

